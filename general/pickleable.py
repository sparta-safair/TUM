"""
Provides the base class for classes that can pickle their chkp, init, etc
(attacks and models)

"""

# Standard imports
import abc
import os
import sys
from glob import glob

# Third party imports
import pickle

# Constants
MSG_PARAMS = 'Wrong number of params! Expected %d, got %d'
PICKLE_FINAL, PICKLE_PARTIAL = 2, 1

INIT, CHKP, FINAL = 'init', 'chkp', 'final'
STORAGE_TYPES = {INIT, CHKP, FINAL}


class Pickleable:
    """
    Base class for model, attack. Provides functionality for .pickling
    chkp, init, and final files and loading them
    """
    def __init__(self, verb, keys_chkp, keys_final):
        """ Constructor """
        self.verb = verb
        self.keys = {CHKP: keys_chkp, FINAL: keys_final}

    def save_pickle(self, keys, params, path):
        """
        Save dict [keys: params] to .pickle file path

        :param keys: [list(str)] list of keys to store under
        :param params: [list(*)] list of params to store
        :param path: [pathlib.Path] path to save .pickle at
        """
        param_dict = self.get_dict(keys, params)

        out = open(str(path), 'wb')
        pickle.dump(param_dict, out)
        out.close()

    @staticmethod
    def get_dict(keys, params):
        """ Put params into dictionary for state saving """
        if len(params) != len(keys):
            raise ValueError(MSG_PARAMS % (len(keys), len(params)))

        return dict(zip(keys, params))

    @staticmethod
    def load_pickle(keys, f_name):
        """
        Load .pickle file and return parameters

        :param f_name: [str] full path to relevant pickle file
        :param keys: [list(str)] list of keys to zip with

        :returns: (...) Tuple of all params (from dict) in pickle
        """
        file = open(str(f_name), 'rb')
        params = pickle.load(file)
        if len(keys) == 1:
            return params[keys[0]]
        return tuple([params[key] for key in keys])

    def load_final(self, f_name):
        """
        Load .pickle file of final values and return params

        :param f_name: [str] full path to .pickle file

        :returns: [list(int, float), float] scores, thresh
        """
        return self.load_pickle(self.keys[FINAL], f_name)

    def get_pickle(self, tag=CHKP):
        """
        Retrieve .pickle file name from folder

        :param chkp: [str] {'chkp', 'init', 'final'}

        :returns: (file_name, status)
            file_name: [str] full path to file to retrieve (or used pattern)
            status: [int] flag in [PICKLE_FINAL, PICKLE_PARTIAL, 0]
        """
        if tag not in STORAGE_TYPES:
            raise ValueError('%s not in %s' % (tag, STORAGE_TYPES))
        if tag == CHKP:
            pattern = str(self.get_folder_chkp() / self.get_chkp_name())
            file_final = pattern % ''
            file_search = pattern % '*'
        elif tag == INIT:
            pattern = str(self.get_folder_init() / self.get_init_name())
            file_final, file_search = pattern, pattern
        elif tag == FINAL:
            pattern = str(self.get_folder_final() / self.get_final_name())
            file_final, file_search = pattern, pattern

        list_files = sorted(glob(file_search))
        if file_final in list_files:
            return file_final, PICKLE_FINAL
        if list_files:
            return list_files[-1], PICKLE_PARTIAL
        return pattern, 0

    def save_checkpoint(self, params, suffix=''):
        """
        Save current state to checkpoint. Loaded and used by subclasses.

        :param param_dict: [dict[str]] key-values generated by param_dict()
        :param index: [str] suffix to file name
        """

        path = self.get_folder_chkp()
        if not path.exists():
            os.makedirs(path)

        file = self.get_chkp_name() % suffix
        path = path / file

        self.print_verbose('Saving checkpoint %s ...' % file, end=' ')
        self.save_pickle(self.keys[CHKP], params, path)
        self.print_verbose('done')

    def save_initial(self, keys, params, text=''):
        """
        Save initialized values for reuse for next program call.
        Creates parent directory, if not exists, then calls 'save_pickle'

        :param keys: [list(str)] list of keys to store
        :param param: [list(*)] list of values to store
        """
        path = self.get_folder_init()
        if not path.exists():
            os.makedirs(path)

        path = path / self.get_init_name()

        self.print_verbose('Saving initial params (%s) ...' % text, end=' ')
        self.save_pickle(keys, params, path)
        self.print_verbose('done')

    def save_final(self, params):
        """
        Save final values for reuse for next program call.
        Creates parent directory, if not exists, then calls 'save_pickle'

        :param params: [list(*)] list of final values to store
        """
        path = self.get_folder_final()
        if not path.exists():
            os.makedirs(path)

        path = path / self.get_final_name()

        self.print_verbose('Saving final results ...', end=' ')
        self.save_pickle(self.keys[FINAL], params, path)
        self.print_verbose('done')

    def print_verbose(self, text='', end='\n'):
        """
        General API for printing from model. Checks if self.verb is on,
        then prints and flushes stdout (for instant printing)

        :param text: [str] text to print
        :param end: [str] trailing token until next text
        """
        if self.verb:
            print(text, end=end)
            sys.stdout.flush()


    # Define methods subclasses MUST implement

    @abc.abstractmethod
    def get_folder_chkp(self):
        """ Return folder for checkpoints """
        pass

    @abc.abstractmethod
    def get_folder_init(self):
        """ Return folder for initialzations """
        pass

    @abc.abstractmethod
    def get_folder_final(self):
        """ Return folder for final vals """
        pass

    @abc.abstractmethod
    def get_chkp_name(self):
        """ Return name for checkpoint (with %s) """
        pass

    @abc.abstractmethod
    def get_init_name(self):
        """ Return name for initialzation """
        pass

    @abc.abstractmethod
    def get_final_name(self):
        """ Return name for final vals """
        pass
